name: Auto-Fix PR Title

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  auto-fix-title:
    name: Auto-Fix PR Title with AI
    runs-on: ubuntu-latest
    # Only run if the PR title validation has failed
    if: github.event.pull_request.draft == false
    steps:
      - uses: actions/checkout@v4

      - name: Check if title needs fixing
        id: check-title
        uses: actions/github-script@v7
        with:
          script: |
            const title = context.payload.pull_request.title;
            
            // Check if title follows conventional commit format
            const conventionalCommitRegex = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build)(\(.+\))?:\s.+/;
            const needsFix = !conventionalCommitRegex.test(title);
            
            core.setOutput('needs_fix', needsFix);
            core.setOutput('current_title', title);
            
            if (needsFix) {
              console.log(`Title needs fixing: "${title}"`);
            } else {
              console.log(`Title is valid: "${title}"`);
            }

      - name: Analyze PR content and generate new title
        if: steps.check-title.outputs.needs_fix == 'true'
        id: generate-title
        uses: actions/github-script@v7
        with:
          script: |
            // Use context directly to avoid interpolation issues
            const currentTitle = context.payload.pull_request.title;
            const prBody = context.payload.pull_request.body || '';
            
            // Get the list of changed files
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Handle empty PR case
            if (files.data.length === 0) {
              core.setOutput('new_title', 'chore: ' + currentTitle);
              core.setOutput('suggested_type', 'chore');
              core.setOutput('confidence', 'low');
              console.log('No files changed, defaulting to chore type');
              return;
            }
            
            const changedFiles = files.data.map(f => f.filename).join('\n');
            const fileCategories = {
              docs: ['.md', '.txt', 'README', 'LICENSE', 'CONTRIBUTING'],
              test: ['test', 'spec', '__tests__', '.test.', '.spec.'],
              ci: ['.github/workflows', '.github/actions', 'ci.yml', 'cd.yml'],
              build: ['Makefile', 'package.json', 'requirements.txt', 'Dockerfile', 'docker-compose'],
              frontend: ['frontend/', 'src/components/', 'src/screens/', '.jsx', '.tsx'],
              backend: ['backend/', 'api/', 'server/'],
              config: ['config/', '.env', 'settings', '.yml', '.yaml', '.json'],
            };
            
            // Keyword patterns for content analysis
            const contentKeywords = {
              feat: ['add', 'new', 'create', 'implement', 'introduce'],
              fix: ['fix', 'bug', 'issue', 'error', 'patch', 'resolve'],
              refactor: ['refactor', 'restructure', 'reorganize', 'cleanup', 'clean up'],
              perf: ['performance', 'perf', 'optimize', 'speed', 'faster'],
              style: ['style', 'format', 'lint', 'prettier', 'eslint'],
            };
            
            // Analyze changed files to determine the type
            let suggestedType = 'chore';
            let confidence = 'low';
            
            // Count matches for each category
            const categoryScores = {};
            for (const [category, patterns] of Object.entries(fileCategories)) {
              categoryScores[category] = files.data.filter(f => 
                patterns.some(pattern => f.filename.includes(pattern))
              ).length;
            }
            
            // Determine the most likely type based on file changes
            if (categoryScores.docs > 0 && categoryScores.docs === files.data.length) {
              suggestedType = 'docs';
              confidence = 'high';
            } else if (categoryScores.test > 0 && categoryScores.test === files.data.length) {
              suggestedType = 'test';
              confidence = 'high';
            } else if (categoryScores.ci > 0) {
              suggestedType = 'ci';
              confidence = categoryScores.ci === files.data.length ? 'high' : 'medium';
            } else if (categoryScores.build > 0) {
              suggestedType = 'build';
              confidence = 'medium';
            } else {
              // Analyze title and description for keywords
              const content = (currentTitle + ' ' + prBody).toLowerCase();
              
              // Check each type's keywords in priority order (feat and fix are most common)
              const keywordTypes = ['feat', 'fix', 'refactor', 'perf', 'style'];
              for (const type of keywordTypes) {
                if (contentKeywords[type]) {
                  const pattern = new RegExp('\\b(' + contentKeywords[type].join('|') + ')\\b', 'i');
                  if (pattern.test(content)) {
                    suggestedType = type;
                    confidence = 'medium';
                    break;
                  }
                }
              }
            }
            
            // Clean up the current title to create a better description
            let cleanTitle = currentTitle
              .replace(/^(feat|fix|docs|style|refactor|perf|test|chore|ci|build)(\(.+\))?:\s*/i, '')
              .trim();
            
            // Capitalize first letter if needed
            cleanTitle = cleanTitle.charAt(0).toUpperCase() + cleanTitle.slice(1);
            
            // Remove trailing punctuation
            cleanTitle = cleanTitle.replace(/[.!?]+$/, '');
            
            const newTitle = `${suggestedType}: ${cleanTitle}`;
            
            core.setOutput('new_title', newTitle);
            core.setOutput('suggested_type', suggestedType);
            core.setOutput('confidence', confidence);
            
            console.log(`Suggested type: ${suggestedType} (confidence: ${confidence})`);
            console.log(`New title: ${newTitle}`);

      - name: Update PR title
        if: steps.check-title.outputs.needs_fix == 'true'
        uses: actions/github-script@v7
        env:
          NEW_TITLE: ${{ steps.generate-title.outputs.new_title }}
          SUGGESTED_TYPE: ${{ steps.generate-title.outputs.suggested_type }}
          CONFIDENCE: ${{ steps.generate-title.outputs.confidence }}
        with:
          script: |
            // Get values from environment variables (safer than string interpolation)
            const newTitle = process.env.NEW_TITLE;
            const suggestedType = process.env.SUGGESTED_TYPE;
            const confidence = process.env.CONFIDENCE;
            const previousTitle = context.payload.pull_request.title;
            
            // Update the PR title
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              title: newTitle
            });
            
            // Add a comment to explain the change
            // Note: GitHub API properly escapes content in comments, preventing XSS
            const comment = [
              'ðŸ¤– **AI PR Title Auto-Fix**',
              '',
              'I\'ve automatically updated the PR title to follow [Conventional Commits](https://www.conventionalcommits.org/) format:',
              '',
              `**Previous title:** \`${previousTitle}\``,
              `**New title:** \`${newTitle}\``,
              '',
              '**Analysis:**',
              `- Suggested type: \`${suggestedType}\``,
              `- Confidence: ${confidence}`,
              '',
              'If this isn\'t quite right, you can manually edit the PR title. The format should be:',
              '```',
              '<type>: <description>',
              '```',
              '',
              'Valid types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`, `ci`, `build`'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
            
            console.log('âœ… PR title updated and comment posted');
